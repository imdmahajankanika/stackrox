// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v2/compliance_scan_schedule_service.proto

package v2

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Represents the role of the node within the cluster
type NodeRole int32

const (
	NodeRole_INFRA  NodeRole = 0
	NodeRole_WORKER NodeRole = 1
	NodeRole_MASTER NodeRole = 2
)

var NodeRole_name = map[int32]string{
	0: "INFRA",
	1: "WORKER",
	2: "MASTER",
}

var NodeRole_value = map[string]int32{
	"INFRA":  0,
	"WORKER": 1,
	"MASTER": 2,
}

func (x NodeRole) String() string {
	return proto.EnumName(NodeRole_name, int32(x))
}

func (NodeRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{0}
}

// ClusterScanStatus holds status based on cluster in the event that a schedule was
// successfully applied to some clusters but not others.
type ClusterScanStatus struct {
	ClusterId            string   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Errors               []string `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterScanStatus) Reset()         { *m = ClusterScanStatus{} }
func (m *ClusterScanStatus) String() string { return proto.CompactTextString(m) }
func (*ClusterScanStatus) ProtoMessage()    {}
func (*ClusterScanStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{0}
}
func (m *ClusterScanStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterScanStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterScanStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterScanStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterScanStatus.Merge(m, src)
}
func (m *ClusterScanStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterScanStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterScanStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterScanStatus proto.InternalMessageInfo

func (m *ClusterScanStatus) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ClusterScanStatus) GetErrors() []string {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *ClusterScanStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ClusterScanStatus) Clone() *ClusterScanStatus {
	if m == nil {
		return nil
	}
	cloned := new(ClusterScanStatus)
	*cloned = *m

	if m.Errors != nil {
		cloned.Errors = make([]string, len(m.Errors))
		copy(cloned.Errors, m.Errors)
	}
	return cloned
}

type BaseComplianceScanScheduleSettings struct {
	AutoApplyRemediations  bool       `protobuf:"varint,1,opt,name=auto_apply_remediations,json=autoApplyRemediations,proto3" json:"auto_apply_remediations,omitempty"`
	AutoUpdateRemediations bool       `protobuf:"varint,2,opt,name=auto_update_remediations,json=autoUpdateRemediations,proto3" json:"auto_update_remediations,omitempty"`
	OneTimeScan            bool       `protobuf:"varint,3,opt,name=one_time_scan,json=oneTimeScan,proto3" json:"one_time_scan,omitempty"`
	Profiles               []string   `protobuf:"bytes,4,rep,name=profiles,proto3" json:"profiles,omitempty"`
	Schedule               *Schedule  `protobuf:"bytes,5,opt,name=schedule,proto3" json:"schedule,omitempty"`
	NodeRoles              []NodeRole `protobuf:"varint,6,rep,packed,name=node_roles,json=nodeRoles,proto3,enum=v2.NodeRole" json:"node_roles,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}   `json:"-"`
	XXX_unrecognized       []byte     `json:"-"`
	XXX_sizecache          int32      `json:"-"`
}

func (m *BaseComplianceScanScheduleSettings) Reset()         { *m = BaseComplianceScanScheduleSettings{} }
func (m *BaseComplianceScanScheduleSettings) String() string { return proto.CompactTextString(m) }
func (*BaseComplianceScanScheduleSettings) ProtoMessage()    {}
func (*BaseComplianceScanScheduleSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{1}
}
func (m *BaseComplianceScanScheduleSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseComplianceScanScheduleSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseComplianceScanScheduleSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseComplianceScanScheduleSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseComplianceScanScheduleSettings.Merge(m, src)
}
func (m *BaseComplianceScanScheduleSettings) XXX_Size() int {
	return m.Size()
}
func (m *BaseComplianceScanScheduleSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseComplianceScanScheduleSettings.DiscardUnknown(m)
}

var xxx_messageInfo_BaseComplianceScanScheduleSettings proto.InternalMessageInfo

func (m *BaseComplianceScanScheduleSettings) GetAutoApplyRemediations() bool {
	if m != nil {
		return m.AutoApplyRemediations
	}
	return false
}

func (m *BaseComplianceScanScheduleSettings) GetAutoUpdateRemediations() bool {
	if m != nil {
		return m.AutoUpdateRemediations
	}
	return false
}

func (m *BaseComplianceScanScheduleSettings) GetOneTimeScan() bool {
	if m != nil {
		return m.OneTimeScan
	}
	return false
}

func (m *BaseComplianceScanScheduleSettings) GetProfiles() []string {
	if m != nil {
		return m.Profiles
	}
	return nil
}

func (m *BaseComplianceScanScheduleSettings) GetSchedule() *Schedule {
	if m != nil {
		return m.Schedule
	}
	return nil
}

func (m *BaseComplianceScanScheduleSettings) GetNodeRoles() []NodeRole {
	if m != nil {
		return m.NodeRoles
	}
	return nil
}

func (m *BaseComplianceScanScheduleSettings) MessageClone() proto.Message {
	return m.Clone()
}
func (m *BaseComplianceScanScheduleSettings) Clone() *BaseComplianceScanScheduleSettings {
	if m == nil {
		return nil
	}
	cloned := new(BaseComplianceScanScheduleSettings)
	*cloned = *m

	if m.Profiles != nil {
		cloned.Profiles = make([]string, len(m.Profiles))
		copy(cloned.Profiles, m.Profiles)
	}
	cloned.Schedule = m.Schedule.Clone()
	if m.NodeRoles != nil {
		cloned.NodeRoles = make([]NodeRole, len(m.NodeRoles))
		copy(cloned.NodeRoles, m.NodeRoles)
	}
	return cloned
}

type ComplianceScanScheduleConfiguration struct {
	ScanName             string                              `protobuf:"bytes,1,opt,name=scan_name,json=scanName,proto3" json:"scan_name,omitempty"`
	ScanScheduleConfig   *BaseComplianceScanScheduleSettings `protobuf:"bytes,2,opt,name=scan_schedule_config,json=scanScheduleConfig,proto3" json:"scan_schedule_config,omitempty"`
	Clusters             []string                            `protobuf:"bytes,3,rep,name=clusters,proto3" json:"clusters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ComplianceScanScheduleConfiguration) Reset()         { *m = ComplianceScanScheduleConfiguration{} }
func (m *ComplianceScanScheduleConfiguration) String() string { return proto.CompactTextString(m) }
func (*ComplianceScanScheduleConfiguration) ProtoMessage()    {}
func (*ComplianceScanScheduleConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{2}
}
func (m *ComplianceScanScheduleConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceScanScheduleConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceScanScheduleConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceScanScheduleConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceScanScheduleConfiguration.Merge(m, src)
}
func (m *ComplianceScanScheduleConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceScanScheduleConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceScanScheduleConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceScanScheduleConfiguration proto.InternalMessageInfo

func (m *ComplianceScanScheduleConfiguration) GetScanName() string {
	if m != nil {
		return m.ScanName
	}
	return ""
}

func (m *ComplianceScanScheduleConfiguration) GetScanScheduleConfig() *BaseComplianceScanScheduleSettings {
	if m != nil {
		return m.ScanScheduleConfig
	}
	return nil
}

func (m *ComplianceScanScheduleConfiguration) GetClusters() []string {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *ComplianceScanScheduleConfiguration) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceScanScheduleConfiguration) Clone() *ComplianceScanScheduleConfiguration {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceScanScheduleConfiguration)
	*cloned = *m

	cloned.ScanScheduleConfig = m.ScanScheduleConfig.Clone()
	if m.Clusters != nil {
		cloned.Clusters = make([]string, len(m.Clusters))
		copy(cloned.Clusters, m.Clusters)
	}
	return cloned
}

type ComplianceScanScheduleStatus struct {
	ScanName           string                              `protobuf:"bytes,1,opt,name=scan_name,json=scanName,proto3" json:"scan_name,omitempty"`
	ScanScheduleConfig *BaseComplianceScanScheduleSettings `protobuf:"bytes,2,opt,name=scan_schedule_config,json=scanScheduleConfig,proto3" json:"scan_schedule_config,omitempty"`
	Clusters           []*ClusterScanStatus                `protobuf:"bytes,3,rep,name=clusters,proto3" json:"clusters,omitempty"`
	CreatedTime        *types.Timestamp                    `protobuf:"bytes,4,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	LastUpdatedTime    *types.Timestamp                    `protobuf:"bytes,5,opt,name=last_updated_time,json=lastUpdatedTime,proto3" json:"last_updated_time,omitempty"`
	// Most recent user to update the scan settings
	CreatedBy            *SlimUser `protobuf:"bytes,6,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ComplianceScanScheduleStatus) Reset()         { *m = ComplianceScanScheduleStatus{} }
func (m *ComplianceScanScheduleStatus) String() string { return proto.CompactTextString(m) }
func (*ComplianceScanScheduleStatus) ProtoMessage()    {}
func (*ComplianceScanScheduleStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{3}
}
func (m *ComplianceScanScheduleStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceScanScheduleStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceScanScheduleStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceScanScheduleStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceScanScheduleStatus.Merge(m, src)
}
func (m *ComplianceScanScheduleStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceScanScheduleStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceScanScheduleStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceScanScheduleStatus proto.InternalMessageInfo

func (m *ComplianceScanScheduleStatus) GetScanName() string {
	if m != nil {
		return m.ScanName
	}
	return ""
}

func (m *ComplianceScanScheduleStatus) GetScanScheduleConfig() *BaseComplianceScanScheduleSettings {
	if m != nil {
		return m.ScanScheduleConfig
	}
	return nil
}

func (m *ComplianceScanScheduleStatus) GetClusters() []*ClusterScanStatus {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *ComplianceScanScheduleStatus) GetCreatedTime() *types.Timestamp {
	if m != nil {
		return m.CreatedTime
	}
	return nil
}

func (m *ComplianceScanScheduleStatus) GetLastUpdatedTime() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedTime
	}
	return nil
}

func (m *ComplianceScanScheduleStatus) GetCreatedBy() *SlimUser {
	if m != nil {
		return m.CreatedBy
	}
	return nil
}

func (m *ComplianceScanScheduleStatus) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceScanScheduleStatus) Clone() *ComplianceScanScheduleStatus {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceScanScheduleStatus)
	*cloned = *m

	cloned.ScanScheduleConfig = m.ScanScheduleConfig.Clone()
	if m.Clusters != nil {
		cloned.Clusters = make([]*ClusterScanStatus, len(m.Clusters))
		for idx, v := range m.Clusters {
			cloned.Clusters[idx] = v.Clone()
		}
	}
	cloned.CreatedTime = m.CreatedTime.Clone()
	cloned.LastUpdatedTime = m.LastUpdatedTime.Clone()
	cloned.CreatedBy = m.CreatedBy.Clone()
	return cloned
}

type ComplianceScanScheduleConfigRequest struct {
	ScanName             string   `protobuf:"bytes,1,opt,name=scan_name,json=scanName,proto3" json:"scan_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComplianceScanScheduleConfigRequest) Reset()         { *m = ComplianceScanScheduleConfigRequest{} }
func (m *ComplianceScanScheduleConfigRequest) String() string { return proto.CompactTextString(m) }
func (*ComplianceScanScheduleConfigRequest) ProtoMessage()    {}
func (*ComplianceScanScheduleConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{4}
}
func (m *ComplianceScanScheduleConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceScanScheduleConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceScanScheduleConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceScanScheduleConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceScanScheduleConfigRequest.Merge(m, src)
}
func (m *ComplianceScanScheduleConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceScanScheduleConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceScanScheduleConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceScanScheduleConfigRequest proto.InternalMessageInfo

func (m *ComplianceScanScheduleConfigRequest) GetScanName() string {
	if m != nil {
		return m.ScanName
	}
	return ""
}

func (m *ComplianceScanScheduleConfigRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComplianceScanScheduleConfigRequest) Clone() *ComplianceScanScheduleConfigRequest {
	if m == nil {
		return nil
	}
	cloned := new(ComplianceScanScheduleConfigRequest)
	*cloned = *m

	return cloned
}

type ListComplianceScanScheduleResponse struct {
	Schedules            []*ComplianceScanScheduleStatus `protobuf:"bytes,1,rep,name=schedules,proto3" json:"schedules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ListComplianceScanScheduleResponse) Reset()         { *m = ListComplianceScanScheduleResponse{} }
func (m *ListComplianceScanScheduleResponse) String() string { return proto.CompactTextString(m) }
func (*ListComplianceScanScheduleResponse) ProtoMessage()    {}
func (*ListComplianceScanScheduleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_930f94887ba4b7fc, []int{5}
}
func (m *ListComplianceScanScheduleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListComplianceScanScheduleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListComplianceScanScheduleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListComplianceScanScheduleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListComplianceScanScheduleResponse.Merge(m, src)
}
func (m *ListComplianceScanScheduleResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListComplianceScanScheduleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListComplianceScanScheduleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListComplianceScanScheduleResponse proto.InternalMessageInfo

func (m *ListComplianceScanScheduleResponse) GetSchedules() []*ComplianceScanScheduleStatus {
	if m != nil {
		return m.Schedules
	}
	return nil
}

func (m *ListComplianceScanScheduleResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListComplianceScanScheduleResponse) Clone() *ListComplianceScanScheduleResponse {
	if m == nil {
		return nil
	}
	cloned := new(ListComplianceScanScheduleResponse)
	*cloned = *m

	if m.Schedules != nil {
		cloned.Schedules = make([]*ComplianceScanScheduleStatus, len(m.Schedules))
		for idx, v := range m.Schedules {
			cloned.Schedules[idx] = v.Clone()
		}
	}
	return cloned
}

func init() {
	proto.RegisterEnum("v2.NodeRole", NodeRole_name, NodeRole_value)
	proto.RegisterType((*ClusterScanStatus)(nil), "v2.ClusterScanStatus")
	proto.RegisterType((*BaseComplianceScanScheduleSettings)(nil), "v2.BaseComplianceScanScheduleSettings")
	proto.RegisterType((*ComplianceScanScheduleConfiguration)(nil), "v2.ComplianceScanScheduleConfiguration")
	proto.RegisterType((*ComplianceScanScheduleStatus)(nil), "v2.ComplianceScanScheduleStatus")
	proto.RegisterType((*ComplianceScanScheduleConfigRequest)(nil), "v2.ComplianceScanScheduleConfigRequest")
	proto.RegisterType((*ListComplianceScanScheduleResponse)(nil), "v2.ListComplianceScanScheduleResponse")
}

func init() {
	proto.RegisterFile("api/v2/compliance_scan_schedule_service.proto", fileDescriptor_930f94887ba4b7fc)
}

var fileDescriptor_930f94887ba4b7fc = []byte{
	// 840 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0xae, 0x37, 0xcd, 0x6a, 0xf7, 0xdd, 0x02, 0xc9, 0x40, 0x8b, 0xeb, 0x26, 0xe9, 0xca, 0x08,
	0x58, 0x12, 0xd5, 0xab, 0xb8, 0x08, 0x01, 0x12, 0x48, 0x49, 0x48, 0x51, 0xf9, 0x08, 0x68, 0x92,
	0x8a, 0x8a, 0x8b, 0x35, 0xb1, 0xdf, 0x04, 0x0b, 0x7b, 0xc6, 0x78, 0xc6, 0x4b, 0x23, 0xc4, 0x05,
	0x09, 0x09, 0x71, 0xe5, 0x52, 0x7e, 0x04, 0x77, 0x7e, 0x02, 0x47, 0x24, 0xfe, 0x00, 0x0a, 0xdc,
	0xf9, 0x03, 0x1c, 0xd0, 0x8c, 0xc7, 0x9b, 0x2c, 0xed, 0xee, 0x96, 0x82, 0xc4, 0xcd, 0x7e, 0xbf,
	0xe6, 0x79, 0x9f, 0xe7, 0x99, 0x81, 0x1b, 0xac, 0x48, 0x87, 0xa3, 0x70, 0x18, 0x8b, 0xbc, 0xc8,
	0x52, 0xc6, 0x63, 0x8c, 0x64, 0xcc, 0x78, 0x24, 0xe3, 0x4f, 0x30, 0xa9, 0x32, 0x8c, 0x24, 0x96,
	0xa3, 0x34, 0xc6, 0xa0, 0x28, 0x85, 0x12, 0xa4, 0x35, 0x0a, 0xbd, 0xeb, 0xc7, 0x42, 0x1c, 0x67,
	0x38, 0x34, 0x91, 0xc3, 0xea, 0x68, 0xa8, 0xd2, 0x1c, 0xa5, 0x62, 0x79, 0x51, 0x17, 0x79, 0x2b,
	0xb6, 0x40, 0x8f, 0x66, 0x9c, 0x0b, 0xc5, 0x54, 0x2a, 0xb8, 0xb4, 0xd9, 0xa7, 0xcf, 0x4e, 0xcc,
	0x05, 0xb7, 0xc1, 0x65, 0x1b, 0xac, 0x24, 0x96, 0x75, 0xc8, 0x7f, 0x07, 0x96, 0x77, 0xb2, 0x4a,
	0x2a, 0x2c, 0xf7, 0x63, 0xc6, 0xf7, 0x15, 0x53, 0x95, 0x24, 0xab, 0x00, 0x71, 0x1d, 0x8c, 0xd2,
	0xc4, 0x75, 0xfa, 0xce, 0xa0, 0x4b, 0xbb, 0x36, 0x72, 0x3b, 0x21, 0x57, 0xa0, 0x8d, 0x65, 0x29,
	0x4a, 0xe9, 0xb6, 0xfa, 0x0b, 0x83, 0x2e, 0xb5, 0x7f, 0xfe, 0x0f, 0x2d, 0xf0, 0xb7, 0x99, 0xc4,
	0x9d, 0xf1, 0x96, 0x66, 0xa6, 0xdd, 0x71, 0x1f, 0x95, 0x4a, 0xf9, 0xb1, 0x24, 0xaf, 0xc0, 0xb3,
	0xac, 0x52, 0x22, 0x62, 0x45, 0x91, 0x9d, 0x44, 0x25, 0xe6, 0x98, 0xa4, 0x35, 0x76, 0x73, 0x54,
	0x87, 0x5e, 0xd6, 0xe9, 0x2d, 0x9d, 0xa5, 0xe7, 0x92, 0xe4, 0x55, 0x70, 0x4d, 0x5f, 0x55, 0x24,
	0x4c, 0xe1, 0x64, 0x63, 0xcb, 0x34, 0x5e, 0xd1, 0xf9, 0x3b, 0x26, 0x3d, 0xd1, 0xe9, 0xc3, 0x13,
	0x82, 0x63, 0xa4, 0x19, 0x34, 0xbc, 0xbb, 0x0b, 0xa6, 0xbc, 0x27, 0x38, 0x1e, 0xa4, 0xb9, 0x41,
	0x49, 0x3c, 0xe8, 0x14, 0xa5, 0x38, 0x4a, 0x33, 0x94, 0xee, 0x45, 0xb3, 0xd6, 0xf8, 0x9f, 0x0c,
	0xa0, 0xd3, 0x28, 0xe5, 0x2e, 0xf6, 0x9d, 0x41, 0x2f, 0xbc, 0x14, 0x8c, 0xc2, 0xa0, 0xd9, 0x8c,
	0x8e, 0xb3, 0x64, 0x03, 0x80, 0x8b, 0x04, 0xa3, 0x52, 0xe8, 0x39, 0xed, 0xfe, 0xc2, 0xe0, 0xc9,
	0xba, 0x76, 0x4f, 0x24, 0x48, 0x45, 0x86, 0xb4, 0xcb, 0xed, 0x97, 0xf4, 0x7f, 0x74, 0xe0, 0xb9,
	0x87, 0x73, 0xb5, 0x23, 0xf8, 0x51, 0x7a, 0x5c, 0x95, 0x06, 0x3f, 0xb9, 0x06, 0x5d, 0xe3, 0x16,
	0xce, 0x72, 0xb4, 0x6a, 0x74, 0x74, 0x60, 0x8f, 0xe5, 0x48, 0xee, 0xc2, 0x33, 0x93, 0x56, 0x8a,
	0x4d, 0xaf, 0x61, 0xa4, 0x17, 0xbe, 0xa0, 0xcf, 0x9e, 0xaf, 0x09, 0x25, 0xf2, 0x81, 0xd3, 0x35,
	0x23, 0x56, 0x73, 0xe9, 0x2e, 0xd4, 0x8c, 0x34, 0xff, 0xfe, 0x9f, 0x2d, 0x58, 0x99, 0x32, 0xb2,
	0xb6, 0xd0, 0xff, 0x84, 0x79, 0xf3, 0x6f, 0x98, 0x7b, 0xe1, 0x65, 0x3d, 0xed, 0x01, 0x8b, 0x9f,
	0xad, 0x42, 0xde, 0x80, 0x4b, 0x71, 0x89, 0x4c, 0x61, 0x62, 0x0c, 0xe2, 0x5e, 0x34, 0x20, 0xbc,
	0xa0, 0xbe, 0x5e, 0x41, 0x73, 0xff, 0x82, 0x83, 0xe6, 0xfe, 0xd1, 0x9e, 0xad, 0xd7, 0x11, 0x72,
	0x0b, 0x96, 0x33, 0x26, 0x95, 0x75, 0xa5, 0x9d, 0xb1, 0x38, 0x77, 0xc6, 0x53, 0xba, 0xa9, 0xb6,
	0x6a, 0x3d, 0x67, 0x03, 0xa0, 0x81, 0x71, 0x78, 0xe2, 0xb6, 0xcf, 0xb9, 0x2c, 0x4b, 0xf3, 0x3b,
	0x12, 0x4b, 0xda, 0xb5, 0xf9, 0xed, 0x13, 0x7f, 0x7b, 0xb6, 0x71, 0x28, 0x7e, 0x56, 0xa1, 0x54,
	0x33, 0x45, 0xf0, 0x13, 0xf0, 0xdf, 0x4b, 0xa5, 0x7a, 0xf8, 0x1c, 0x8a, 0xb2, 0x10, 0x5c, 0x22,
	0x79, 0x53, 0x8f, 0xa8, 0x63, 0xfa, 0x7a, 0x6a, 0x46, 0xfb, 0x86, 0xd1, 0x19, 0xe2, 0xd3, 0xb3,
	0x96, 0xf5, 0x1b, 0xd0, 0x69, 0xac, 0x4f, 0xba, 0xb0, 0x78, 0x7b, 0xef, 0x16, 0xdd, 0x5a, 0xba,
	0x40, 0x00, 0xda, 0x1f, 0x7d, 0x40, 0xdf, 0xdd, 0xa5, 0x4b, 0x8e, 0xfe, 0x7e, 0x7f, 0x6b, 0xff,
	0x60, 0x97, 0x2e, 0xb5, 0xc2, 0x3f, 0xda, 0xb0, 0x3a, 0x4d, 0x76, 0xf3, 0x42, 0x92, 0xcf, 0xe1,
	0xda, 0x74, 0xd8, 0x92, 0x74, 0x35, 0xb8, 0xdd, 0xbc, 0x50, 0x27, 0x9e, 0xf1, 0xd1, 0xfc, 0x15,
	0xfd, 0xe7, 0xbf, 0xfa, 0xe5, 0xf7, 0xef, 0x5a, 0xd7, 0xc9, 0xea, 0xe4, 0x0b, 0x3d, 0xd4, 0x4c,
	0x0d, 0xc7, 0x9b, 0x90, 0xef, 0x1d, 0xb8, 0xfa, 0x36, 0x4e, 0x19, 0x46, 0x5e, 0x9c, 0x4e, 0xca,
	0x84, 0x26, 0xde, 0x5c, 0xf6, 0xfc, 0x4d, 0x83, 0x67, 0x83, 0xbc, 0x34, 0x13, 0xcf, 0xf0, 0x8b,
	0xb1, 0xb4, 0x5f, 0x92, 0xfb, 0x0e, 0x78, 0x1f, 0x0a, 0xf9, 0xd8, 0xe0, 0xec, 0x4b, 0xe3, 0x3d,
	0x6a, 0xa1, 0x3f, 0x30, 0x18, 0x7d, 0x7f, 0x36, 0x67, 0xaf, 0x3b, 0xeb, 0xe4, 0x1b, 0x07, 0x56,
	0x6a, 0x9f, 0xff, 0x5b, 0x70, 0x67, 0xd2, 0xfa, 0x2f, 0x9b, 0xe3, 0x03, 0xef, 0xd1, 0x29, 0xd2,
	0x50, 0xbe, 0x76, 0x60, 0xe5, 0x2d, 0xcc, 0xf0, 0xf1, 0xa1, 0x34, 0x22, 0x9e, 0x83, 0x62, 0xd5,
	0x5a, 0xff, 0x07, 0x6a, 0x7d, 0xeb, 0xc0, 0x55, 0x5a, 0xf1, 0xff, 0x10, 0xc4, 0x6b, 0x06, 0xc4,
	0x4d, 0xb2, 0x39, 0x1b, 0x04, 0xde, 0xc3, 0xb8, 0x52, 0x78, 0x1e, 0xcc, 0x76, 0xf0, 0xd3, 0xe9,
	0x9a, 0xf3, 0xf3, 0xe9, 0x9a, 0xf3, 0xeb, 0xe9, 0x9a, 0x73, 0xff, 0xb7, 0xb5, 0x0b, 0xe0, 0xa6,
	0x22, 0x90, 0x8a, 0xc5, 0x9f, 0x96, 0xe2, 0x5e, 0xfd, 0x74, 0x05, 0xac, 0x48, 0x83, 0x51, 0xf8,
	0x71, 0x6b, 0x14, 0xde, 0x75, 0x0e, 0xdb, 0x26, 0x76, 0xf3, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xb1, 0x54, 0x47, 0x4b, 0xd5, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ComplianceScanScheduleServiceClient is the client API for ComplianceScanScheduleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type ComplianceScanScheduleServiceClient interface {
	// ListComplianceScanSchedules lists all the compliance operator schedules for the secured clusters
	ListComplianceScanSchedules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListComplianceScanScheduleResponse, error)
	// GetComplianceScanSchedule retrieves the specified compliance scan schedule
	GetComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfigRequest, opts ...grpc.CallOption) (*ComplianceScanScheduleStatus, error)
	// PostComplianceScanSchedule creates a compliance scan schedule configuration
	PostComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfiguration, opts ...grpc.CallOption) (*ComplianceScanScheduleConfiguration, error)
	// UpdateComplianceScanSchedule updates a compliance scan schedule configuration
	UpdateComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfiguration, opts ...grpc.CallOption) (*Empty, error)
	// DeleteComplianceScanSchedule removes the compliance scan schedule with given Name
	DeleteComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfigRequest, opts ...grpc.CallOption) (*Empty, error)
	// RunComplianceScanSchedule launches scan for the specified schedule
	RunComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfigRequest, opts ...grpc.CallOption) (*Empty, error)
}

type complianceScanScheduleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewComplianceScanScheduleServiceClient(cc grpc.ClientConnInterface) ComplianceScanScheduleServiceClient {
	return &complianceScanScheduleServiceClient{cc}
}

func (c *complianceScanScheduleServiceClient) ListComplianceScanSchedules(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListComplianceScanScheduleResponse, error) {
	out := new(ListComplianceScanScheduleResponse)
	err := c.cc.Invoke(ctx, "/v2.ComplianceScanScheduleService/ListComplianceScanSchedules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceScanScheduleServiceClient) GetComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfigRequest, opts ...grpc.CallOption) (*ComplianceScanScheduleStatus, error) {
	out := new(ComplianceScanScheduleStatus)
	err := c.cc.Invoke(ctx, "/v2.ComplianceScanScheduleService/GetComplianceScanSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceScanScheduleServiceClient) PostComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfiguration, opts ...grpc.CallOption) (*ComplianceScanScheduleConfiguration, error) {
	out := new(ComplianceScanScheduleConfiguration)
	err := c.cc.Invoke(ctx, "/v2.ComplianceScanScheduleService/PostComplianceScanSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceScanScheduleServiceClient) UpdateComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfiguration, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v2.ComplianceScanScheduleService/UpdateComplianceScanSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceScanScheduleServiceClient) DeleteComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v2.ComplianceScanScheduleService/DeleteComplianceScanSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *complianceScanScheduleServiceClient) RunComplianceScanSchedule(ctx context.Context, in *ComplianceScanScheduleConfigRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v2.ComplianceScanScheduleService/RunComplianceScanSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ComplianceScanScheduleServiceServer is the server API for ComplianceScanScheduleService service.
type ComplianceScanScheduleServiceServer interface {
	// ListComplianceScanSchedules lists all the compliance operator schedules for the secured clusters
	ListComplianceScanSchedules(context.Context, *Empty) (*ListComplianceScanScheduleResponse, error)
	// GetComplianceScanSchedule retrieves the specified compliance scan schedule
	GetComplianceScanSchedule(context.Context, *ComplianceScanScheduleConfigRequest) (*ComplianceScanScheduleStatus, error)
	// PostComplianceScanSchedule creates a compliance scan schedule configuration
	PostComplianceScanSchedule(context.Context, *ComplianceScanScheduleConfiguration) (*ComplianceScanScheduleConfiguration, error)
	// UpdateComplianceScanSchedule updates a compliance scan schedule configuration
	UpdateComplianceScanSchedule(context.Context, *ComplianceScanScheduleConfiguration) (*Empty, error)
	// DeleteComplianceScanSchedule removes the compliance scan schedule with given Name
	DeleteComplianceScanSchedule(context.Context, *ComplianceScanScheduleConfigRequest) (*Empty, error)
	// RunComplianceScanSchedule launches scan for the specified schedule
	RunComplianceScanSchedule(context.Context, *ComplianceScanScheduleConfigRequest) (*Empty, error)
}

// UnimplementedComplianceScanScheduleServiceServer can be embedded to have forward compatible implementations.
type UnimplementedComplianceScanScheduleServiceServer struct {
}

func (*UnimplementedComplianceScanScheduleServiceServer) ListComplianceScanSchedules(ctx context.Context, req *Empty) (*ListComplianceScanScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListComplianceScanSchedules not implemented")
}
func (*UnimplementedComplianceScanScheduleServiceServer) GetComplianceScanSchedule(ctx context.Context, req *ComplianceScanScheduleConfigRequest) (*ComplianceScanScheduleStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComplianceScanSchedule not implemented")
}
func (*UnimplementedComplianceScanScheduleServiceServer) PostComplianceScanSchedule(ctx context.Context, req *ComplianceScanScheduleConfiguration) (*ComplianceScanScheduleConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostComplianceScanSchedule not implemented")
}
func (*UnimplementedComplianceScanScheduleServiceServer) UpdateComplianceScanSchedule(ctx context.Context, req *ComplianceScanScheduleConfiguration) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateComplianceScanSchedule not implemented")
}
func (*UnimplementedComplianceScanScheduleServiceServer) DeleteComplianceScanSchedule(ctx context.Context, req *ComplianceScanScheduleConfigRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteComplianceScanSchedule not implemented")
}
func (*UnimplementedComplianceScanScheduleServiceServer) RunComplianceScanSchedule(ctx context.Context, req *ComplianceScanScheduleConfigRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunComplianceScanSchedule not implemented")
}

func RegisterComplianceScanScheduleServiceServer(s *grpc.Server, srv ComplianceScanScheduleServiceServer) {
	s.RegisterService(&_ComplianceScanScheduleService_serviceDesc, srv)
}

func _ComplianceScanScheduleService_ListComplianceScanSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceScanScheduleServiceServer).ListComplianceScanSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ComplianceScanScheduleService/ListComplianceScanSchedules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceScanScheduleServiceServer).ListComplianceScanSchedules(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceScanScheduleService_GetComplianceScanSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceScanScheduleConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceScanScheduleServiceServer).GetComplianceScanSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ComplianceScanScheduleService/GetComplianceScanSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceScanScheduleServiceServer).GetComplianceScanSchedule(ctx, req.(*ComplianceScanScheduleConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceScanScheduleService_PostComplianceScanSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceScanScheduleConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceScanScheduleServiceServer).PostComplianceScanSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ComplianceScanScheduleService/PostComplianceScanSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceScanScheduleServiceServer).PostComplianceScanSchedule(ctx, req.(*ComplianceScanScheduleConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceScanScheduleService_UpdateComplianceScanSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceScanScheduleConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceScanScheduleServiceServer).UpdateComplianceScanSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ComplianceScanScheduleService/UpdateComplianceScanSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceScanScheduleServiceServer).UpdateComplianceScanSchedule(ctx, req.(*ComplianceScanScheduleConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceScanScheduleService_DeleteComplianceScanSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceScanScheduleConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceScanScheduleServiceServer).DeleteComplianceScanSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ComplianceScanScheduleService/DeleteComplianceScanSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceScanScheduleServiceServer).DeleteComplianceScanSchedule(ctx, req.(*ComplianceScanScheduleConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ComplianceScanScheduleService_RunComplianceScanSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceScanScheduleConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ComplianceScanScheduleServiceServer).RunComplianceScanSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v2.ComplianceScanScheduleService/RunComplianceScanSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ComplianceScanScheduleServiceServer).RunComplianceScanSchedule(ctx, req.(*ComplianceScanScheduleConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ComplianceScanScheduleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v2.ComplianceScanScheduleService",
	HandlerType: (*ComplianceScanScheduleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListComplianceScanSchedules",
			Handler:    _ComplianceScanScheduleService_ListComplianceScanSchedules_Handler,
		},
		{
			MethodName: "GetComplianceScanSchedule",
			Handler:    _ComplianceScanScheduleService_GetComplianceScanSchedule_Handler,
		},
		{
			MethodName: "PostComplianceScanSchedule",
			Handler:    _ComplianceScanScheduleService_PostComplianceScanSchedule_Handler,
		},
		{
			MethodName: "UpdateComplianceScanSchedule",
			Handler:    _ComplianceScanScheduleService_UpdateComplianceScanSchedule_Handler,
		},
		{
			MethodName: "DeleteComplianceScanSchedule",
			Handler:    _ComplianceScanScheduleService_DeleteComplianceScanSchedule_Handler,
		},
		{
			MethodName: "RunComplianceScanSchedule",
			Handler:    _ComplianceScanScheduleService_RunComplianceScanSchedule_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v2/compliance_scan_schedule_service.proto",
}

func (m *ClusterScanStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterScanStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterScanStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseComplianceScanScheduleSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseComplianceScanScheduleSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseComplianceScanScheduleSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeRoles) > 0 {
		dAtA2 := make([]byte, len(m.NodeRoles)*10)
		var j1 int
		for _, num := range m.NodeRoles {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x32
	}
	if m.Schedule != nil {
		{
			size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Profiles) > 0 {
		for iNdEx := len(m.Profiles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Profiles[iNdEx])
			copy(dAtA[i:], m.Profiles[iNdEx])
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.Profiles[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.OneTimeScan {
		i--
		if m.OneTimeScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AutoUpdateRemediations {
		i--
		if m.AutoUpdateRemediations {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AutoApplyRemediations {
		i--
		if m.AutoApplyRemediations {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceScanScheduleConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceScanScheduleConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceScanScheduleConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Clusters[iNdEx])
			copy(dAtA[i:], m.Clusters[iNdEx])
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.Clusters[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ScanScheduleConfig != nil {
		{
			size, err := m.ScanScheduleConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScanName) > 0 {
		i -= len(m.ScanName)
		copy(dAtA[i:], m.ScanName)
		i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.ScanName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceScanScheduleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceScanScheduleStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceScanScheduleStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedBy != nil {
		{
			size, err := m.CreatedBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LastUpdatedTime != nil {
		{
			size, err := m.LastUpdatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CreatedTime != nil {
		{
			size, err := m.CreatedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ScanScheduleConfig != nil {
		{
			size, err := m.ScanScheduleConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScanName) > 0 {
		i -= len(m.ScanName)
		copy(dAtA[i:], m.ScanName)
		i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.ScanName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceScanScheduleConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceScanScheduleConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceScanScheduleConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ScanName) > 0 {
		i -= len(m.ScanName)
		copy(dAtA[i:], m.ScanName)
		i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(len(m.ScanName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListComplianceScanScheduleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListComplianceScanScheduleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListComplianceScanScheduleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Schedules) > 0 {
		for iNdEx := len(m.Schedules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schedules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintComplianceScanScheduleService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintComplianceScanScheduleService(dAtA []byte, offset int, v uint64) int {
	offset -= sovComplianceScanScheduleService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClusterScanStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovComplianceScanScheduleService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaseComplianceScanScheduleSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoApplyRemediations {
		n += 2
	}
	if m.AutoUpdateRemediations {
		n += 2
	}
	if m.OneTimeScan {
		n += 2
	}
	if len(m.Profiles) > 0 {
		for _, s := range m.Profiles {
			l = len(s)
			n += 1 + l + sovComplianceScanScheduleService(uint64(l))
		}
	}
	if m.Schedule != nil {
		l = m.Schedule.Size()
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if len(m.NodeRoles) > 0 {
		l = 0
		for _, e := range m.NodeRoles {
			l += sovComplianceScanScheduleService(uint64(e))
		}
		n += 1 + sovComplianceScanScheduleService(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceScanScheduleConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScanName)
	if l > 0 {
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if m.ScanScheduleConfig != nil {
		l = m.ScanScheduleConfig.Size()
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if len(m.Clusters) > 0 {
		for _, s := range m.Clusters {
			l = len(s)
			n += 1 + l + sovComplianceScanScheduleService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceScanScheduleStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScanName)
	if l > 0 {
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if m.ScanScheduleConfig != nil {
		l = m.ScanScheduleConfig.Size()
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovComplianceScanScheduleService(uint64(l))
		}
	}
	if m.CreatedTime != nil {
		l = m.CreatedTime.Size()
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if m.LastUpdatedTime != nil {
		l = m.LastUpdatedTime.Size()
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if m.CreatedBy != nil {
		l = m.CreatedBy.Size()
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComplianceScanScheduleConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScanName)
	if l > 0 {
		n += 1 + l + sovComplianceScanScheduleService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListComplianceScanScheduleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Schedules) > 0 {
		for _, e := range m.Schedules {
			l = e.Size()
			n += 1 + l + sovComplianceScanScheduleService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovComplianceScanScheduleService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozComplianceScanScheduleService(x uint64) (n int) {
	return sovComplianceScanScheduleService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterScanStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterScanStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterScanStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceScanScheduleService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseComplianceScanScheduleSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseComplianceScanScheduleSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseComplianceScanScheduleSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoApplyRemediations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoApplyRemediations = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoUpdateRemediations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoUpdateRemediations = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneTimeScan = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profiles = append(m.Profiles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schedule == nil {
				m.Schedule = &Schedule{}
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v NodeRole
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceScanScheduleService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= NodeRole(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NodeRoles = append(m.NodeRoles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowComplianceScanScheduleService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthComplianceScanScheduleService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthComplianceScanScheduleService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.NodeRoles) == 0 {
					m.NodeRoles = make([]NodeRole, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v NodeRole
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowComplianceScanScheduleService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= NodeRole(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NodeRoles = append(m.NodeRoles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeRoles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceScanScheduleService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceScanScheduleConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceScanScheduleConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceScanScheduleConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanScheduleConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanScheduleConfig == nil {
				m.ScanScheduleConfig = &BaseComplianceScanScheduleSettings{}
			}
			if err := m.ScanScheduleConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceScanScheduleService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceScanScheduleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceScanScheduleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceScanScheduleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanScheduleConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanScheduleConfig == nil {
				m.ScanScheduleConfig = &BaseComplianceScanScheduleSettings{}
			}
			if err := m.ScanScheduleConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &ClusterScanStatus{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedTime == nil {
				m.CreatedTime = &types.Timestamp{}
			}
			if err := m.CreatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedTime == nil {
				m.LastUpdatedTime = &types.Timestamp{}
			}
			if err := m.LastUpdatedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedBy == nil {
				m.CreatedBy = &SlimUser{}
			}
			if err := m.CreatedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceScanScheduleService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceScanScheduleConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceScanScheduleConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceScanScheduleConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScanName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceScanScheduleService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListComplianceScanScheduleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListComplianceScanScheduleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListComplianceScanScheduleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schedules = append(m.Schedules, &ComplianceScanScheduleStatus{})
			if err := m.Schedules[len(m.Schedules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipComplianceScanScheduleService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthComplianceScanScheduleService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipComplianceScanScheduleService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowComplianceScanScheduleService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowComplianceScanScheduleService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthComplianceScanScheduleService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupComplianceScanScheduleService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthComplianceScanScheduleService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthComplianceScanScheduleService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowComplianceScanScheduleService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupComplianceScanScheduleService = fmt.Errorf("proto: unexpected end of group")
)
